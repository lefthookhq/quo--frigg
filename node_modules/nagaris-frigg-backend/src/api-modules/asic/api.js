const { Requester } = require('@friggframework/core');
const crypto = require('crypto');

/**
 * ASIC SOAP API Client
 * Handles Form 362 (Agent Appointment) and Form 484 (Company Details Change)
 */
class Api extends Requester {
    constructor(params) {
        super(params);

        // Use UAT endpoint by default (can be overridden)
        this.baseUrl = params.useProduction
            ? 'https://asic.gov.au/webservices/agent'
            : 'https://uat.asic.gov.au/webservices/agent';

        this.username = null;
        this.password = null;
        this.senderId = null;
        this.senderType = 'REGA'; // Default to Registered Agent
    }

    /**
     * Set credentials for HTTP Basic Authentication
     */
    async setCredential(credential) {
        this.credential = credential;

        if (credential.username && credential.password) {
            this.username = credential.username;
            this.password = credential.password;
            this.senderId = credential.senderId;
            this.senderType = credential.senderType || 'REGA';
        }
    }

    /**
     * Add HTTP Basic Auth headers
     */
    async addAuthHeaders(headers) {
        if (this.username && this.password) {
            const auth = Buffer.from(`${this.username}:${this.password}`).toString('base64');
            headers['Authorization'] = `Basic ${auth}`;
        }
        return headers;
    }

    /**
     * Generate a unique message reference number
     */
    generateMessageReference() {
        const timestamp = Date.now();
        const random = crypto.randomBytes(4).toString('hex');
        return `MSG_${timestamp}_${random}`.toUpperCase();
    }

    /**
     * Build SOAP envelope wrapper
     */
    buildSOAPEnvelope(body) {
        return `<?xml version="1.0" encoding="UTF-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <soap:Header/>
  <soap:Body>
    ${body}
  </soap:Body>
</soap:Envelope>`;
    }

    /**
     * Build Form 362 XML (Agent Appointment)
     * @param {Object} params
     * @param {string} params.acn - Company ACN (9 digits)
     * @param {string} params.companyName - Company legal name
     * @param {string} params.agentNumber - ASIC Registered Agent Number
     * @param {string} params.agentName - Agent firm name
     * @param {string} params.agentAddress - Agent address
     * @param {string} params.signatoryName - Director's full name
     * @param {string} params.signatoryCapacity - Director's capacity (e.g., 'DIR')
     * @param {string} params.dateSigned - Date signed (YYYY-MM-DD format)
     * @returns {string} Complete SOAP XML message
     */
    buildForm362XML(params) {
        const {
            acn,
            companyName,
            agentNumber,
            agentName,
            agentAddress,
            signatoryName,
            signatoryCapacity = 'DIR',
            dateSigned
        } = params;

        const messageRef = this.generateMessageReference();

        const body = `
    <external.bn.lodge.request:bnLodgeApplicationRequest
        xmlns:external.bn.lodge.request="http://asic.gov.au/schemas/external/bn/lodge/request">
      <businessDocumentHeader>
        <messageType>ASC362</messageType>
        <messageReferenceNumber>${messageRef}</messageReferenceNumber>
        <senderId>${this.senderId}</senderId>
        <senderType>${this.senderType}</senderType>
        <receiverId>ASIC</receiverId>
        <messageDateTime>${new Date().toISOString()}</messageDateTime>
      </businessDocumentHeader>
      <businessDocumentBody>
        <companyDetails>
          <acn>${acn}</acn>
          <name>${this.escapeXml(companyName)}</name>
        </companyDetails>
        <agentDetails action="A">
          <agentNumber>${agentNumber}</agentNumber>
          <agentName>${this.escapeXml(agentName)}</agentName>
          <address>${this.escapeXml(agentAddress)}</address>
        </agentDetails>
        <signatory>
          <name>${this.escapeXml(signatoryName)}</name>
          <capacity>${signatoryCapacity}</capacity>
          <dateSigned>${dateSigned}</dateSigned>
          <declaration>true</declaration>
        </signatory>
      </businessDocumentBody>
    </external.bn.lodge.request:bnLodgeApplicationRequest>`;

        return this.buildSOAPEnvelope(body);
    }

    /**
     * Build Form 484 XML (Company Details Change)
     * @param {Object} params
     * @param {string} params.acn - Company ACN (9 digits)
     * @param {Object} params.changes - Object containing the changes to be made
     * @param {string} params.signatoryName - Director's full name
     * @param {string} params.signatoryCapacity - Director's capacity
     * @param {string} params.dateSigned - Date signed (YYYY-MM-DD format)
     * @returns {string} Complete SOAP XML message
     */
    buildForm484XML(params) {
        const {
            acn,
            changes,
            signatoryName,
            signatoryCapacity = 'DIR',
            dateSigned
        } = params;

        const messageRef = this.generateMessageReference();

        // Build change elements based on what's being changed
        let changeElements = '';

        if (changes.name) {
            changeElements += `
          <nameChange>
            <newName>${this.escapeXml(changes.name)}</newName>
          </nameChange>`;
        }

        if (changes.registeredOffice) {
            changeElements += `
          <registeredOfficeChange>
            <address>${this.escapeXml(changes.registeredOffice)}</address>
          </registeredOfficeChange>`;
        }

        if (changes.principalPlaceOfBusiness) {
            changeElements += `
          <principalPlaceChange>
            <address>${this.escapeXml(changes.principalPlaceOfBusiness)}</address>
          </principalPlaceChange>`;
        }

        const body = `
    <external.company.lodge.request:companyLodgeApplicationRequest
        xmlns:external.company.lodge.request="http://asic.gov.au/schemas/external/company/lodge/request">
      <businessDocumentHeader>
        <messageType>ASC484</messageType>
        <messageReferenceNumber>${messageRef}</messageReferenceNumber>
        <senderId>${this.senderId}</senderId>
        <senderType>${this.senderType}</senderType>
        <receiverId>ASIC</receiverId>
        <messageDateTime>${new Date().toISOString()}</messageDateTime>
      </businessDocumentHeader>
      <businessDocumentBody>
        <companyDetails>
          <acn>${acn}</acn>
        </companyDetails>
        <changes>${changeElements}
        </changes>
        <signatory>
          <name>${this.escapeXml(signatoryName)}</name>
          <capacity>${signatoryCapacity}</capacity>
          <dateSigned>${dateSigned}</dateSigned>
          <declaration>true</declaration>
        </signatory>
      </businessDocumentBody>
    </external.company.lodge.request:companyLodgeApplicationRequest>`;

        return this.buildSOAPEnvelope(body);
    }

    /**
     * Submit Form 362 (Agent Appointment)
     */
    async submitForm362(params) {
        if (!this.username || !this.password || !this.senderId) {
            throw new Error('Credentials not set. Call setCredential first.');
        }

        const soapXml = this.buildForm362XML(params);

        const options = {
            url: this.baseUrl,
            headers: {
                'Content-Type': 'text/xml; charset=utf-8',
                'SOAPAction': 'bnLodgeApplication'
            },
            body: soapXml
        };

        return this._post(options, false);
    }

    /**
     * Submit Form 484 (Company Details Change)
     */
    async submitForm484(params) {
        if (!this.username || !this.password || !this.senderId) {
            throw new Error('Credentials not set. Call setCredential first.');
        }

        const soapXml = this.buildForm484XML(params);

        const options = {
            url: this.baseUrl,
            headers: {
                'Content-Type': 'text/xml; charset=utf-8',
                'SOAPAction': 'companyLodgeApplication'
            },
            body: soapXml
        };

        return this._post(options, false);
    }

    /**
     * Build RA71 XML (Request for Company Details)
     * @param {Object} params
     * @param {string} params.acn - Company ACN (9 digits)
     * @param {string} params.companyName - Company legal name
     * @param {string} params.requestType - Type of request: 'DATA' for data download, 'CURRENT' for current statement
     * @returns {string} Complete SOAP XML message
     */
    buildRA71XML(params) {
        const {
            acn,
            companyName,
            requestType = 'DATA' // Default to data download
        } = params;

        const messageRef = this.generateMessageReference();
        const dateSigned = new Date().toISOString().split('T')[0].replace(/-/g, '');

        const body = `
    <external.agent.request:agentServiceRequest
        xmlns:external.agent.request="http://asic.gov.au/schemas/external/agent/request">
      <businessDocumentHeader>
        <messageType>ASCRA71</messageType>
        <messageReferenceNumber>${messageRef}</messageReferenceNumber>
        <senderId>${this.senderId}</senderId>
        <senderType>${this.senderType}</senderType>
        <receiverId>ASIC</receiverId>
        <messageDateTime>${new Date().toISOString()}</messageDateTime>
      </businessDocumentHeader>
      <businessDocumentBody>
        <declaration>
          <signingAgentName>${this.escapeXml(this.username)}</signingAgentName>
          <signingAgentOffice>${this.senderType}</signingAgentOffice>
          <dateSigned>${dateSigned}</dateSigned>
          <authorisedToRequest>true</authorisedToRequest>
        </declaration>
        <companyIdentification>
          <companyName>${this.escapeXml(companyName)}</companyName>
          <acn>${acn}</acn>
          <requestType>${requestType}</requestType>
        </companyIdentification>
      </businessDocumentBody>
    </external.agent.request:agentServiceRequest>`;

        return this.buildSOAPEnvelope(body);
    }

    /**
     * Request Company Details via RA71
     * Returns RA72 response with company data
     * @param {Object} params
     * @param {string} params.acn - Company ACN (9 digits)
     * @param {string} params.companyName - Company legal name
     * @param {string} params.requestType - 'DATA' for full data, 'CURRENT' for current statement
     * @returns {Promise<Object>} Company details response
     */
    async requestCompanyDetails(params) {
        if (!this.username || !this.password || !this.senderId) {
            throw new Error('Credentials not set. Call setCredential first.');
        }

        const soapXml = this.buildRA71XML(params);

        const options = {
            url: this.baseUrl,
            headers: {
                'Content-Type': 'text/xml; charset=utf-8',
                'SOAPAction': 'agentServiceRequest'
            },
            body: soapXml
        };

        return this._post(options, false);
    }

    /**
     * Parse RA72 Company Details Response
     * Extracts key company information from the XML response
     * @param {string} xmlResponse - Raw XML response from ASIC
     * @returns {Object} Parsed company details
     */
    parseRA72Response(xmlResponse) {
        // Extract company identification
        const companyNameMatch = xmlResponse.match(/<companyName>([^<]+)<\/companyName>/);
        const acnMatch = xmlResponse.match(/<acn>([^<]+)<\/acn>/);
        const companyTypeMatch = xmlResponse.match(/<companyType>([^<]+)<\/companyType>/);
        const companyClassMatch = xmlResponse.match(/<companyClass>([^<]+)<\/companyClass>/);
        const currentStatusMatch = xmlResponse.match(/<currentStatus>([^<]+)<\/currentStatus>/);
        const dateOfRegistrationMatch = xmlResponse.match(/<dateOfRegistration>([^<]+)<\/dateOfRegistration>/);
        const reviewDateMatch = xmlResponse.match(/<reviewDate>([^<]+)<\/reviewDate>/);

        // Extract registered office
        const regOfficeMatch = xmlResponse.match(/<registeredOffice>([\s\S]*?)<\/registeredOffice>/);
        let registeredOffice = null;
        if (regOfficeMatch) {
            const addressMatch = regOfficeMatch[1].match(/<address>([\s\S]*?)<\/address>/);
            registeredOffice = addressMatch ? this.parseAddress(addressMatch[1]) : null;
        }

        // Extract principal place of business
        const principalPlaceMatch = xmlResponse.match(/<principalPlaceOfBusiness>([\s\S]*?)<\/principalPlaceOfBusiness>/);
        let principalPlace = null;
        if (principalPlaceMatch) {
            const addressMatch = principalPlaceMatch[1].match(/<address>([\s\S]*?)<\/address>/);
            principalPlace = addressMatch ? this.parseAddress(addressMatch[1]) : null;
        }

        // Extract officers
        const officers = this.parseOfficers(xmlResponse);

        // Extract share information
        const shareClasses = this.parseShareClasses(xmlResponse);

        return {
            success: true,
            company: {
                name: companyNameMatch ? companyNameMatch[1] : null,
                acn: acnMatch ? acnMatch[1] : null,
                type: companyTypeMatch ? companyTypeMatch[1] : null,
                class: companyClassMatch ? companyClassMatch[1] : null,
                status: currentStatusMatch ? currentStatusMatch[1] : null,
                dateOfRegistration: dateOfRegistrationMatch ? dateOfRegistrationMatch[1] : null,
                reviewDate: reviewDateMatch ? reviewDateMatch[1] : null,
                registeredOffice,
                principalPlace,
                officers,
                shareClasses
            },
            rawResponse: xmlResponse
        };
    }

    /**
     * Parse address from XML segment
     */
    parseAddress(addressXml) {
        const streetMatch = addressXml.match(/<street>([^<]+)<\/street>/);
        const suburbMatch = addressXml.match(/<suburb>([^<]+)<\/suburb>/);
        const stateMatch = addressXml.match(/<state>([^<]+)<\/state>/);
        const postcodeMatch = addressXml.match(/<postcode>([^<]+)<\/postcode>/);

        return {
            street: streetMatch ? streetMatch[1] : null,
            suburb: suburbMatch ? suburbMatch[1] : null,
            state: stateMatch ? stateMatch[1] : null,
            postcode: postcodeMatch ? postcodeMatch[1] : null
        };
    }

    /**
     * Parse officers from XML response
     */
    parseOfficers(xmlResponse) {
        const officers = [];
        const officerMatches = xmlResponse.match(/<companyOfficer>([\s\S]*?)<\/companyOfficer>/g);

        if (officerMatches) {
            for (const officerXml of officerMatches) {
                const nameMatch = officerXml.match(/<name>([^<]+)<\/name>/);
                const officeMatch = officerXml.match(/<office>([^<]+)<\/office>/);
                const appointmentDateMatch = officerXml.match(/<appointmentDate>([^<]+)<\/appointmentDate>/);

                officers.push({
                    name: nameMatch ? nameMatch[1] : null,
                    office: officeMatch ? officeMatch[1] : null,
                    appointmentDate: appointmentDateMatch ? appointmentDateMatch[1] : null
                });
            }
        }

        return officers;
    }

    /**
     * Parse share classes from XML response
     */
    parseShareClasses(xmlResponse) {
        const shareClasses = [];
        const shareMatches = xmlResponse.match(/<shareClass>([\s\S]*?)<\/shareClass>/g);

        if (shareMatches) {
            for (const shareXml of shareMatches) {
                const classCodeMatch = shareXml.match(/<classCode>([^<]+)<\/classCode>/);
                const fullTitleMatch = shareXml.match(/<fullTitle>([^<]+)<\/fullTitle>/);
                const totalIssuedMatch = shareXml.match(/<totalIssued>([^<]+)<\/totalIssued>/);

                shareClasses.push({
                    classCode: classCodeMatch ? classCodeMatch[1] : null,
                    fullTitle: fullTitleMatch ? fullTitleMatch[1] : null,
                    totalIssued: totalIssuedMatch ? parseInt(totalIssuedMatch[1]) : 0
                });
            }
        }

        return shareClasses;
    }

    /**
     * Test authentication credentials
     * Verifies that credentials are set correctly
     */
    async testAuth() {
        if (!this.username || !this.password || !this.senderId) {
            throw new Error('Invalid credentials: username, password, and senderId are required');
        }

        // Validate sender ID format
        if (!/^[0-9]{9}$/.test(this.senderId)) {
            throw new Error('Invalid sender ID format: must be 9 digits');
        }

        return {
            authenticated: true,
            senderId: this.senderId,
            senderType: this.senderType,
        };
    }

    /**
     * Escape XML special characters
     */
    escapeXml(str) {
        if (!str) return '';
        return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;');
    }

    /**
     * Parse SOAP response
     */
    parseSOAPResponse(xmlResponse) {
        // Basic XML parsing - in production, use a proper XML parser
        const transactionMatch = xmlResponse.match(/<transactionNumber>([^<]+)<\/transactionNumber>/);
        const statusMatch = xmlResponse.match(/<status>([^<]+)<\/status>/);
        const errorMatch = xmlResponse.match(/<error>([^<]+)<\/error>/);

        return {
            success: statusMatch && statusMatch[1] === 'SUCCESS',
            transactionNumber: transactionMatch ? transactionMatch[1] : null,
            status: statusMatch ? statusMatch[1] : 'UNKNOWN',
            error: errorMatch ? errorMatch[1] : null,
            rawResponse: xmlResponse
        };
    }
}

module.exports = { Api };
