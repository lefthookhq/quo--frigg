/* eslint-disable camelcase */
const { Requester } = require('@friggframework/core');

/**
 * FYI Docs API Client
 * Document management and cabinet integration
 */
class Api extends Requester {
    constructor(params) {
        super(params);
        this.baseUrl = 'https://api.fyi.app';
        this.appKey = params.appKey || process.env.FYI_APP_KEY;
        this.userSecret = params.userSecret;

        this.URLs = {
            // Authentication
            userDetails: '/api/v1/user',

            // Cabinet Management (FYI's folder system)
            cabinets: '/api/v1/cabinets',
            cabinetById: (cabinetId) => `/api/v1/cabinets/${cabinetId}`,
            cabinetContents: (cabinetId) => `/api/v1/cabinets/${cabinetId}/contents`,

            // Document Management
            documents: '/api/v1/documents',
            documentById: (documentId) => `/api/v1/documents/${documentId}`,
            uploadDocument: '/api/v1/documents/upload',
            downloadDocument: (documentId) => `/api/v1/documents/${documentId}/download`,
            documentVersions: (documentId) => `/api/v1/documents/${documentId}/versions`,

            // Search and Filtering
            searchDocuments: '/api/v1/documents/search',
            searchCabinets: '/api/v1/cabinets/search',
        };
    }

    async setCredential(credential) {
        this.credential = credential;
        this.appKey = credential.appKey;
        this.userSecret = credential.userSecret;
    }

    /**
     * Add auth headers with app key and user secret
     */
    async addAuthHeaders(headers) {
        headers = await super.addAuthHeaders(headers);
        if (this.appKey) {
            headers['X-App-Key'] = this.appKey;
        }
        if (this.userSecret) {
            headers['X-User-Secret'] = this.userSecret;
        }
        return headers;
    }

    /**
     * Get current user details
     */
    async getUserDetails() {
        const options = {
            url: this.baseUrl + this.URLs.userDetails,
        };
        return this._get(options);
    }

    /**
     * List all cabinets
     * @param {Object} params - Query parameters
     * @param {number} params.page - Which page to list (default: 1)
     * @param {number} params.per_page - Number of units to list, max 500 (default: 10)
     * @param {string} params.name - Wildcard search by name
     * @param {boolean} params.include_deleted - Include deleted units (default: false)
     * @param {string} params.created_on_gte - Lower bound for created_on
     * @param {string} params.created_on_lte - Upper bound for created_on
     * @param {string} params.modified_on_gte - Lower bound for last_modified_on
     * @param {string} params.modified_on_lte - Upper bound for last_modified_on
     * @param {boolean} params.is_knowledge - Return only knowledge cabinets
     */
    async listCabinets(params = {}) {
        const options = {
            url: this.baseUrl + this.URLs.cabinets,
            query: {
                page: 1,
                per_page: 10,
                include_deleted: false,
                ...params,
            },
        };
        return this._get(options);
    }

    /**
     * Get cabinet by ID
     * @param {string} cabinetId - Cabinet ID
     */
    async getCabinet(cabinetId) {
        const options = {
            url: this.baseUrl + this.URLs.cabinetById(cabinetId),
        };
        return this._get(options);
    }

    /**
     * Create a new cabinet
     * @param {Object} params
     * @param {string} params.name - Cabinet name
     * @param {boolean} params.is_knowledge - Knowledge cabinet boolean (default: false)
     */
    async createCabinet({ name, is_knowledge = false }) {
        const options = {
            url: this.baseUrl + this.URLs.cabinets,
            headers: {
                'Content-Type': 'application/json',
            },
            body: {
                name,
                is_knowledge,
            },
        };
        return this._post(options);
    }

    /**
     * Update a cabinet
     * @param {string} cabinetId - Cabinet ID
     * @param {Object} params
     * @param {string} params.name - Cabinet name
     * @param {boolean} params.is_knowledge - Knowledge cabinet boolean
     */
    async updateCabinet(cabinetId, { name, is_knowledge }) {
        const options = {
            url: this.baseUrl + this.URLs.cabinetById(cabinetId),
            headers: {
                'Content-Type': 'application/json',
            },
            body: {
                name,
                is_knowledge,
            },
        };
        return this._put(options);
    }

    /**
     * Delete a cabinet
     * @param {string} cabinetId - Cabinet ID
     */
    async deleteCabinet(cabinetId) {
        const options = {
            url: this.baseUrl + this.URLs.cabinetById(cabinetId),
        };
        return this._delete(options);
    }

    /**
     * Get cabinet contents (documents and sub-cabinets)
     * @param {string} cabinetId - Cabinet ID
     * @param {Object} params - Query parameters
     */
    async getCabinetContents(cabinetId, params = {}) {
        const options = {
            url: this.baseUrl + this.URLs.cabinetContents(cabinetId),
            query: params,
        };
        return this._get(options);
    }

    /**
     * Search cabinets
     * @param {Object} params - Search parameters
     * @param {string} params.name - Wildcard search by name
     * @param {boolean} params.is_knowledge - Return only knowledge cabinets
     * @param {number} params.page - Page number
     * @param {number} params.per_page - Items per page
     */
    async searchCabinets(params = {}) {
        const options = {
            url: this.baseUrl + this.URLs.searchCabinets,
            query: params,
        };
        return this._get(options);
    }

    /**
     * Create standardized cabinet structure for a client
     * Creates the required cabinet hierarchy for document organization
     * @param {Object} params
     * @param {string} params.clientName - Client name
     * @param {string} params.financialYear - Financial year for cabinet structure (e.g., "2024")
     */
    async createClientCabinetStructure({ clientName, financialYear }) {
        const currentYear = financialYear || new Date().getFullYear().toString();

        // Define the standard cabinet structure for FYI
        const cabinetStructure = [
            {
                name: `${clientName} - Permanent`,
                is_knowledge: false,
                subcabinets: [
                    { name: 'Company Constitution', is_knowledge: false },
                    { name: 'ASIC Documents', is_knowledge: false },
                    { name: 'Tax File Numbers', is_knowledge: false },
                ]
            },
            {
                name: `${clientName} - Financial Year ${currentYear}`,
                is_knowledge: false,
                subcabinets: [
                    { name: 'Tax Returns', is_knowledge: false },
                    { name: 'Financial Statements', is_knowledge: false },
                    { name: 'BAS Returns', is_knowledge: false },
                    { name: 'Engagement Letters', is_knowledge: false },
                    { name: 'Ethical Clearances', is_knowledge: false },
                ]
            },
            {
                name: `${clientName} - Accounting and Tax`,
                is_knowledge: false,
                subcabinets: [
                    { name: 'Workpapers', is_knowledge: false },
                    { name: 'Source Documents', is_knowledge: false },
                    { name: 'Correspondence', is_knowledge: false },
                ]
            },
            {
                name: `${clientName} - Corporate Compliance`,
                is_knowledge: false,
                subcabinets: [
                    { name: 'ASIC Lodgements', is_knowledge: false },
                    { name: 'Annual Returns', is_knowledge: false },
                    { name: 'Director Changes', is_knowledge: false },
                ]
            }
        ];

        const createdCabinets = [];

        // Create main cabinet structure
        for (const cabinet of cabinetStructure) {
            try {
                const mainCabinet = await this.createCabinet({
                    name: cabinet.name,
                    is_knowledge: cabinet.is_knowledge,
                });
                createdCabinets.push(mainCabinet);

                // Create subcabinets
                for (const subcabinet of cabinet.subcabinets) {
                    try {
                        const subCabinet = await this.createCabinet({
                            name: subcabinet.name,
                            is_knowledge: subcabinet.is_knowledge,
                        });
                        createdCabinets.push(subCabinet);
                    } catch (error) {
                        // Log error but continue with other cabinets
                        // console.error(`Failed to create subcabinet ${subcabinet.name}:`, error);
                    }
                }
            } catch (error) {
                // Log error but continue with other cabinets
                // console.error(`Failed to create cabinet ${cabinet.name}:`, error);
            }
        }

        return {
            clientName,
            financialYear: currentYear,
            cabinets: createdCabinets,
        };
    }

    /**
     * Upload a document to FYI
     * @param {Object} params
     * @param {string} params.cabinetId - Cabinet ID to upload to
     * @param {Buffer|string} params.file - File content
     * @param {string} params.filename - File name
     * @param {string} params.documentType - Type of document (engagement_letter, ethical_clearance, tax_return, etc.)
     * @param {Object} params.metadata - Additional document metadata
     */
    async uploadDocument({ cabinetId, file, filename, documentType, metadata = {} }) {
        const options = {
            url: this.baseUrl + this.URLs.uploadDocument,
            headers: {
                'Content-Type': 'multipart/form-data',
            },
            body: {
                cabinetId,
                file,
                filename,
                documentType,
                metadata: JSON.stringify(metadata),
            },
        };
        return this._post(options);
    }

    /**
     * Get document by ID
     * @param {string} documentId - Document ID
     */
    async getDocument(documentId) {
        const options = {
            url: this.baseUrl + this.URLs.documentById(documentId),
        };
        return this._get(options);
    }

    /**
     * Download a document
     * @param {string} documentId - Document ID
     */
    async downloadDocument(documentId) {
        const options = {
            url: this.baseUrl + this.URLs.downloadDocument(documentId),
            returnFullRes: true,
        };
        return this._get(options);
    }

    /**
     * Get document versions
     * @param {string} documentId - Document ID
     */
    async getDocumentVersions(documentId) {
        const options = {
            url: this.baseUrl + this.URLs.documentVersions(documentId),
        };
        return this._get(options);
    }

    /**
     * Delete a document
     * @param {string} documentId - Document ID
     */
    async deleteDocument(documentId) {
        const options = {
            url: this.baseUrl + this.URLs.documentById(documentId),
        };
        return this._delete(options);
    }

    /**
     * Search documents
     * @param {Object} params - Search parameters
     * @param {string} params.query - Search query
     * @param {string} params.clientId - Filter by client ID
     * @param {string} params.folderId - Filter by folder ID
     * @param {string} params.documentType - Filter by document type
     */
    async searchDocuments(params = {}) {
        const options = {
            url: this.baseUrl + this.URLs.documents + '/search',
            query: params,
        };
        return this._get(options);
    }

    /**
     * Sync document from Nagaris to FYI
     * This is a high-level method that handles the complete sync process
     * @param {Object} params
     * @param {Object} params.document - Document data from Nagaris
     * @param {string} params.cabinetId - FYI cabinet ID
     * @param {string} params.documentType - Type of document
     */
    async syncDocumentFromNagaris({ document, cabinetId, documentType }) {
        try {
            // Upload document to specified cabinet
            const uploadedDocument = await this.uploadDocument({
                cabinetId,
                file: document.file,
                filename: document.filename,
                documentType,
                metadata: {
                    nagarisDocumentId: document.id,
                    syncDate: new Date().toISOString(),
                    originalUploadDate: document.uploadDate,
                },
            });

            return {
                success: true,
                document: uploadedDocument,
                cabinetId,
            };
        } catch (error) {
            return {
                success: false,
                error: error.message,
            };
        }
    }

}

module.exports = { Api };
